### 基于指针对象的方法
1. 编译器会隐式地帮我们用&p去调用ScaleBy这个方法
2. 不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到
3. 编译器在这里也会给我们隐式地插入*这个操作符

#### 总结一下：
在每一个合法的方法调用表达式中，也就是下面三种情况里的任意一种情况都是可以的：
1. 要么接收器的实际参数和其形式参数是相同的类型，比如两者都是类型T或者都是类型*T：
```go
Point{1, 2}.Distance(q) //  Point
pptr.ScaleBy(2)         // *Point
```
2. 或者接收器实参是类型T，但接收器形参是类型*T，这种情况下编译器会隐式地为我们取变量的地址：
```go
p.ScaleBy(2) // implicit (&p)
```
3. 或者接收器实参是类型*T，形参是类型T。编译器会隐式地为我们解引用，取到指针指向的实际变量：
```go
pptr.Distance(q) // implicit (*pptr)
```

**译注： 作者这里说的比较绕，其实有两点：**
1. 不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。
2. 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。

### Nil也是一个合法的接收器类型
> 由于url.Values是一个map类型，并且间接引用了其key/value对，因此url.Values.Add对这个map里的元素做任何的更新、删除操作对调用方都是可见的。实际上，就像在普通函数中一样，虽然可以通过引用来操作内部值，但在方法想要修改引用本身时是不会影响原始值的，比如把他置换为nil，或者让这个引用指向了其它的对象，调用方都不会受影响。（译注：因为传入的是存储了内存地址的变量，你改变这个变量本身是影响不了原始的变量的，想想C语言，是差不多的）
>  
> 这里说的一个问题是：
> 虽然是引用，可以再内部修改值，但是要是出现了置换操作（直接整体赋值），这样也是修改不了原来值的，在整体值换的下一句（逻辑） 改变量就和原来的值没有了关系！！！


